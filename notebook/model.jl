### A Pluto.jl notebook ###
# v0.15.1

using Markdown
using InteractiveUtils

# â•”â•â•¡ 926e4270-ee52-11eb-15b9-0b59dac4c681
using Pkg; Pkg.develop(path=".."); Pkg.activate("..")

# â•”â•â•¡ 1d009b9d-dcf2-4bdf-8dd8-fef135cb8524
begin
	using SqState
	using QuantumStateBase
	using QuantumStatePlots
	using DataDeps
	using Plots
	using MAT
end;

# â•”â•â•¡ 05865de0-1458-4c59-880c-8619d4c7dd83
md"
# Real time system

JingYu Ning

The real time quantum state tomogrophy system plays an important role in the homodyme experiment. It provides the features of data visualization without delay and get rid of the extremely complex data analasis works.

In this demonstration, we will show you how the data flows and how the machine learning model works.


"

# â•”â•â•¡ d372a693-4a33-45b1-898c-72339f9e910f
md"
## A small yet elegant model

Apart from the intergration of the model implemented by HsenYi, the improvement of perforement is another essential part of real time system.

Therefore I implemented a small yet elegant CNN model that will infer the arguments `r`, `Î¸` and `nÌ„` for a squeezed thermal state to boost the inference process.
"

# â•”â•â•¡ 7a22ff61-a32f-4def-9fd9-23a540791609
m = get_model("model")

# â•”â•â•¡ 6f6ad264-cac8-4a04-906a-e83ebac85136
md"
## Experiment data from the lab

The experiments of the following data are accomplish by YiRu in NTHU
"

# â•”â•â•¡ 1b4271a4-8540-4881-b6cb-7a3dd8e9d0b1
begin
	data_path = joinpath(SqState.data_path(), "Flow")
	files = readdir(data_path)
end

# â•”â•â•¡ 22a0af68-9012-4cc1-aebf-2f91bac387b4
md"
## About the data

The data is generated by the homodyme detector and capture by the oscilloscope.
"

# â•”â•â•¡ 55d14429-f6e6-4db3-a7ea-6aec92fccd7d
begin
	data = SqState.get_data(joinpath("Flow", files[end-1]))
	x_data = SqState.sample(data, 4096)
end

# â•”â•â•¡ 49fe2f66-5f90-4ad3-8ab3-846b6684b9e7
scatter(LinRange(0, 2Ï€, 4096), x_data, size=(800, 400), title="Quadrature data")

# â•”â•â•¡ 8bb50bb4-dbae-4adb-acd6-46dc45d8c109
md"
## Let the model do the magic

the model will infere the arguments for the state via the given quaduture data.
"

# â•”â•â•¡ b015f3e0-89d8-4ecd-a3e5-23d9cc83a6e5
r, Î¸, nÌ„, c1, c2, c3 = SqState.infer_arg(data, 100)

# â•”â•â•¡ d02b6dbc-a45d-4900-881a-30b550564f6d
md"
After the inference, we can construct the quantum state and plot the Wigner function, or apply some operator to it.
"

# â•”â•â•¡ 90a4e898-f95a-4bd1-8825-9c7d8561a683
state =
	c1 * SqueezedState(Î¾(r, Î¸), rep=StateMatrix) +
	c2 * SqueezedThermalState(Î¾(r, Î¸), nÌ„) +
	c3 * ThermalState(nÌ„)

# â•”â•â•¡ d7756447-61ae-49f7-b0cb-ea1ff0432d29
begin
	wf = WignerFunction(LinRange(-3, 3, 101), LinRange(-3, 3, 101))
	plot_wigner(wf(state), Contour)
end

# â•”â•â•¡ 8ff17755-21eb-45c2-adbc-27a5d021f79f
md"
Calculate all args for all data
"

# â•”â•â•¡ 870e4dd3-f8e6-45a1-87ba-721237e00066
begin
	argv = Matrix{Float64}(undef, 6, length(files))
	for i in 1:size(argv, 2)
		dataáµ¢ = SqState.get_data(joinpath("Flow", files[i]))
		argv[:, i:i] .= SqState.infer_arg(dataáµ¢, 10)
	end
end

# â•”â•â•¡ 90e1807a-0779-4156-9b19-44cab50e2efc
scatter(argv[1, :], size=(800, 200), legend=false, title="r")

# â•”â•â•¡ b24b71fc-2f37-408d-9888-318eeba180dd
scatter(argv[2, :], size=(800, 200), legend=false, title="Î¸")

# â•”â•â•¡ c730f57d-1b41-4165-b50c-e564fbda8861
scatter(argv[3, :], size=(800, 200), legend=false, title="nÌ„")

# â•”â•â•¡ 203ee767-c38b-4123-be29-0d237dc57c40
begin
	plot(size=(800, 200), legend=:left)
	scatter!(argv[4, :], label="câ‚")
	scatter!(argv[5, :], label="câ‚‚")
	scatter!(argv[6, :], label="câ‚ƒ")
end

# â•”â•â•¡ 5bb4f85c-af93-456c-af73-2dc069d0237a
md"
## Wigner flow
"

# â•”â•â•¡ 3fdf7f29-b8b6-478b-9b4d-fb96407e99ae
begin
	function get_w(data_name::String; n_sample=10, fix_Î¸=true, dim=70)
		data = SqState.get_data(joinpath("Flow", data_name))
    	state, w = SqState.calc_w(
			SqState.infer_arg(data, n_sample)..., dim, fix_Î¸,
			wf=wf
		)

		return w
	end

	anim = @animate for f in files
		plot_wigner(get_w(f, fix_Î¸=true), QuantumStatePlots.Contour)
		annotate!(-2.5, 2.5, text("$f", :left))
	end

	gif(anim, fps=2)
end

# â•”â•â•¡ c2fcff08-cbab-47f6-b5b3-5a2989b11c91
# begin
# 	ğ°s = Array{Float64}(undef, 101, 101, 21)
# 	for (i, f) in enumerate(files)
# 		ğ°s[:, :, i] .= get_w(f, fix_Î¸=true).ğ°_surface
# 	end

# 	wfile = matopen("w.mat", "w")
# 	write(wfile, "ws", ğ°s)
# 	close(wfile)
# end

# â•”â•â•¡ 87ca3223-89cf-4dc3-aa25-f66e9bb22a2b
# begin
# 	argvfile = matopen("argv.mat", "w")
# 	write(argvfile, "argv", argv)
# 	close(argvfile)
# end

# â•”â•â•¡ e9ea5eba-70fc-40d0-8bb4-62a289305a7c
# begin
# 	rs = [0.0952 0.0809 0.1271 0.1572 0.2652 0.2753 0.3454 0.3492]
# 	nÌ„s = [0.2549 0.2417 0.2283 0.2355 0.2402 0.2761 0.2793 0.2595]
	
# 	ğ°s_sqth = Array{Float64}(undef, 101, 101, 8)
# 	ğ°s_th = Array{Float64}(undef, 101, 101, 8)
# 	for (i, (r, nÌ„)) in enumerate(zip(rs, nÌ„s))
# 		ğ°s_sqth[:, :, i] .= wf(SqueezedThermalState(Î¾(r, 0.), nÌ„)).ğ°_surface
# 		ğ°s_th[:, :, i] .= wf(ThermalState(nÌ„)).ğ°_surface
# 	end
	
# 	w_sqth_th_file = matopen("w_sqth_th.mat", "w")
# 	write(w_sqth_th_file, "w_sqth", ğ°s_sqth)
# 	write(w_sqth_th_file, "w_th", ğ°s_th)
# 	close(w_sqth_th_file)
#   heatmap(ğ°s_sqth[:, :, 8])
# end

# â•”â•â•¡ 16f28d60-1fd4-4f2b-88c3-5f82ae48fd75
# begin
# 	rs = [0.0609 0.1382 0.3428 0.3692 0.4676 0.4820 0.5393 0.5445]
	
# 	ğ°s_sq = Array{Float64}(undef, 101, 101, 8)
# 	for (i, r) in enumerate(rs)
# 		ğ°s_sq[:, :, i] .= wf(SqueezedState(Î¾(r, 0.))).ğ°_surface
# 	end
	
# 	w_sq_file = matopen("w_sq.mat", "w")
# 	write(w_sq_file, "w_sq", ğ°s_sq)
# 	close(w_sq_file)
# 	heatmap(ğ°s_sq[:, :, 8])
# end

# â•”â•â•¡ Cell order:
# â•Ÿâ”€05865de0-1458-4c59-880c-8619d4c7dd83
# â• â•926e4270-ee52-11eb-15b9-0b59dac4c681
# â• â•1d009b9d-dcf2-4bdf-8dd8-fef135cb8524
# â•Ÿâ”€d372a693-4a33-45b1-898c-72339f9e910f
# â• â•7a22ff61-a32f-4def-9fd9-23a540791609
# â•Ÿâ”€6f6ad264-cac8-4a04-906a-e83ebac85136
# â• â•1b4271a4-8540-4881-b6cb-7a3dd8e9d0b1
# â•Ÿâ”€22a0af68-9012-4cc1-aebf-2f91bac387b4
# â• â•55d14429-f6e6-4db3-a7ea-6aec92fccd7d
# â• â•49fe2f66-5f90-4ad3-8ab3-846b6684b9e7
# â•Ÿâ”€8bb50bb4-dbae-4adb-acd6-46dc45d8c109
# â• â•b015f3e0-89d8-4ecd-a3e5-23d9cc83a6e5
# â•Ÿâ”€d02b6dbc-a45d-4900-881a-30b550564f6d
# â• â•90a4e898-f95a-4bd1-8825-9c7d8561a683
# â• â•d7756447-61ae-49f7-b0cb-ea1ff0432d29
# â•Ÿâ”€8ff17755-21eb-45c2-adbc-27a5d021f79f
# â• â•870e4dd3-f8e6-45a1-87ba-721237e00066
# â•Ÿâ”€90e1807a-0779-4156-9b19-44cab50e2efc
# â•Ÿâ”€b24b71fc-2f37-408d-9888-318eeba180dd
# â•Ÿâ”€c730f57d-1b41-4165-b50c-e564fbda8861
# â•Ÿâ”€203ee767-c38b-4123-be29-0d237dc57c40
# â•Ÿâ”€5bb4f85c-af93-456c-af73-2dc069d0237a
# â• â•3fdf7f29-b8b6-478b-9b4d-fb96407e99ae
# â• â•c2fcff08-cbab-47f6-b5b3-5a2989b11c91
# â• â•87ca3223-89cf-4dc3-aa25-f66e9bb22a2b
# â• â•e9ea5eba-70fc-40d0-8bb4-62a289305a7c
# â• â•16f28d60-1fd4-4f2b-88c3-5f82ae48fd75
